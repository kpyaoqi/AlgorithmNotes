# 三数之和

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

### 示例 ：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

### 思路：

对数组进行排序，然后使用三个指针来遍历数组，其中第一个指针 `i` 从头开始，第二个指针 `left` 从 `i+1` 开始，第三个指针 `right` 从尾部开始。根据三者之和与零的比较结果，来移动指针以寻找符合条件的三元组

# 矩阵置零

给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

### 示例：

输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]

### 思路：

使用了两个布尔数组 `row` 和 `col` 来标记哪些行和列包含零元素，然后再次遍历矩阵，根据标记将相应的元素置为零

# 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的所有字母得到的一个新单词。

### 示例:

输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

### 思路：

使用哈希表将排好序的字符串与原始字符串关联起来，代码中的 `sign` 函数将字符串中每个字符的出现次数转化为一个字符串作为键，用于哈希表的索引。这确保了所有字母异位词具有相同的键，而不需要显式地对字符串进行排序。这可以提高效率，特别是在处理大量字符串时

# 无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

### 示例:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

### 思路：

使用滑动窗口来维护一个不含重复字符的子串。它通过遍历字符串，同时维护左边界 `left` 和右边界 `right`，以确保窗口中的字符都是唯一的。如果遇到重复字符，它会将左边界移到重复字符的下一个位置，并继续遍历。在遍历的过程中，它会不断更新最长子串的长度。

# 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

### 示例：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

### 思路：

这个算法使用了中心扩展方法，通过遍历字符串中的每个字符，以该字符为中心，向两侧扩展以找到回文子串。它同时处理了奇数长度和偶数长度的回文串情况。算法会比较每个中心的回文串长度，保留最长的回文串的起始和结束索引，最终返回最长的回文子串。

# 递增的三元子序列

给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。

如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。

## 示例：

输入：nums = [1,2,3,4,5]
输出：true
解释：任何 i < j < k 的三元组都满足题意

## 思路：

这个算法在遍历数组时维护了 `min` 和 `secondMin`，并根据不同的情况来更新它们。如果在遍历结束后没有找到递增子序列，就返回 `false`。如果找到了递增子序列，就返回 `true`。